# 기본

자바스크립트의 모든 값들은 각기 다른 동작들을 하는 동작들의 집합을 가지고 있습니다. 이는 추상적으로 들리나, `message`라는 변수에 다음과 같은 작업을 수행할 때를 봅시다.

```javascript
message.toLowerCase();

message();
```
이 구문을 분석하면, 첫 번째의 코드 라인은 `toLowerCase()`라는 실행 가능한 속성을 호출합니다. 두 번째 라인은 message를 직접 호출합니다.

하지만 message의 값을 모른다고 했을 때(이는 일반적입니다), 우리는 위의 코드들에서 어떤 값들을 얻을 수 있는지 확신할 수 없습니다. 각각의 연산들은 우리가 처음에 어떤 값을 가지고 있는지에 결정됩니다.

- `message`는 호출 가능한지?
- `toLowerCase`라는 속성을 가지고 있는지?
- 가지고 있다면, `toLowerCase`는 호출 가능한지?
- 두 값들이 호출 가능하다면, 그들이 무엇을 반환할지?

위의 질문들에 대한 답은 자바스크립트를 다룰 때 우리가 주로 머리에 떠올려야 하는 것들입니다. 그리고 우리는 모든 세부 사항들을 옳게 처리하길 바랍니다.

`message`가 다음과 같이 정의되었다고 가정합시다.

```javascript
const message = "Hello world!"
```

아마도 당신은, `message.toLowerCase()`를 호출하면 우리는 소문자로 치환된 같은 문자열을 받을 수 있을 것이라 추측할 수 있습니다.

하지만 두 번째 라인은 어떤가요? 자바스크립트에 익숙하다면, 다음의 예외와 함께 실패한다는 것을 알 수 있습니다.

> TypeError: message is not a function

이러한 문제들을 피할수 있다면 좋을 것입니다.

우리가 코드를 실행할 때, 자바스크립트 런타임이 수행할 작업을 선택하는 방법은 값의 타입을 파악하는 것입니다. 그리고 이것이 `TypeError`가 암시하는 것입니다.

`string`과 `number`와 같은 특정한 원시 타입들에 대해 우리는 `typeof`연산자를 통해 런타임에 그들의 타입을 특정할 수 있습니다. 하지만 함수의 경우 이에 대응하는 런타임에 타입을 파악하는 방법이 없습니다. 다음의 함수를 가정합시다.


```javascript
function fn(x){
  return x.flip();
}
```

우리는 코드를 보는 것만으로 위의 코드가 호출 가능한 flip 속성이 있을 때만 동작할 것이라는 걸 알지만, 자바스크립트는 실행되는 동안 우리가 검사하는 것처럼 코드를 표면적으로 보여주지 않습니다. 순수한 자바스크립트에서 `fn`이 특정한 값으로 처리하는 지 확인할 수 있는 방법은 이를 호출해보고 결과를 보는 것 뿐입니다.
이러한 동작은 코드가 실행되기 전에 어떻게 동작할지 예상하기 힘들게 합니다. 이는 코드를 작성하는 동안 어떻게 동작할 지 알기 어렵게 합니다.

이러한 방향에서, `타입`은 어떤 값들이 `fn`에 전달될 수 있고, 전달되지 못할 지 설명하는 하나의 개념입니다. 자바스크립트는 오로지 순수하게 동적 타이핑을 제공합니다.

다른 방법은 정적 타입 시스템을 이용하여 코드를 실행하기 전에 예상하는 것입니다. 이는

## 정적 타입 체킹

앞서 말한 `TypeError`에서, string을 함수처럼 호출하려 했던 것을 생각해 보면, 대부분의 사람들은 그들의 코드를 실행하는 도중에 어떤 종류의 에러도 만나고 싶허하지 않습니다. 그리고 우리가 새 코드를 짤 때, 우리는 새 버그를 만들지 않기 위해 최대한 노력을 합니다.

만약 우리가 조금의 코드를 추가하고, 저장하고, 다시 코드를 실행했을 때, 즉각 에러를 볼 수 있다면, 우리는 문제를 빠르게 격리할 수 있습니다. 하지만 항상 그렇지는 않습니다. 우리는 충분히 기능을 테스트하지 못했을 수도 있고, 그래서 우리는 발생할 수 있는 에러를 실행해보지 않았을 수 있습니다. 혹은, 운좋게 에러를 발견해서 큰 리팩토링과 삽질해야 할 수많은 코드들을 추가해야 할 수도 있습니다.

이상적으로, 우리는 코드를 실행하기 전에 이러한 버그를 찾을 수 있는 도구를 가질 수 있습니다. 이거는 타입스크립트가 하는 것과 같은 정적 타입 체커라는 것입니다. 정적 타입 시스템은 우리가 프로그램을 실행할 때 값이 어떤 형태와 동작을 할지를 설명하는 것입니다. 타입스크립트가 사용하는 것과 같은 타입 체커는 예외 상황에서 어떤 일들이 일어날지 우리에게 알려줍니다.

```typescript
const message = "hello";

message()
//^~~~~~~~~~
//This expression is not callable
//Type 'String' has no call signatures
```

## 예외 없는 실패

지금까지 우리는 런타임 에러와 같은 것들에 대해 논의하였습니다. 이러한 것들은 예상치 못한 상황에서 언어가 어떻게 동작해야 하는지 ECMAScript 스펙에 명시적으로 지정되어있습니다. 예를 들어, 호출할 수 없는 것에 대해 호출하려고 할 때 에러를 던지게끔 명세되어 있습니다. 그것이 당연한 동작이라고 생각할 수 있지만, 객체에 존재하지 않는 속성에 대한 접근도 에러를 던져야 한다고 생각할 수도 있을 것이나, Javascript는 undefined를 반환합니다.

```javascript
const user = {
  name :"Daniel",
  age:26
};

user.location; // returns undefined
```

궁극적으로, 정적 타입은 즉각적으로 경고를 발생하지 않는 유효한 자바스크립트 코드일지라도 우리의 코드에서 발생하는 시스템 에러에 대해 에러를 호출해줍니다. 타입스크립트에서, 다음의 코드는 location이 정의되지 않았다는 에러를 발생할 것이다.

```typescript
const user = {
  name :"Daniel",
  age:26
};

user.location;
//^~~~~~~~~~~~ Property location does not exist on type '{ name: string; age:number; }'
```

가끔 이것은 표현의 자유를 제한할 수 있으나, 이 의도는 우리의 프로그램 안에서 본격적인 버그들을 잡기 위함입니다. 그리고 타입스크립트는 많은 버그들을 잡을 수 있습니다.

예를 들어 오타나,

```typescript
const announcement = "Hello World";

//얼마나 빨리 오타를 찾을 수 있나요?
announcement.toLocaleLowerCase()
announcement.toLocalLowerCase()
```

호출되지 않은 함수이나,

```typescript
function flipCoin(){
  //Math.random을 의도했을 것입니다
  return Math.random < 0.5
  //^~~~~~~~~~~~~~~~~~~~~~
  //Operator '<' cannot be applied to types '()=>number' and 'number'
}
```

혹은 기본적인 논리 오류들

```typescript
const value = Math.random() < 0.5 ? 'a':'b';
if(value!=='a'){
  //...
} else if(value ==='b'){
  //unreachable
  //This condition will always return 'false' since the types 'a' and 'b' have no overlap
}
```

## 도구를 위한 타입들

타입스크립트는 우리가 코드에서 실수를 만드는 것을 방지할 수 있습니다. 이것은 좋습니다만, 타입스크립트는 이 뿐 아니라 이러한 실수들을 만들지 않게끔도 합니다.

타입 검사기는 
